// Display:
// https://www.adafruit.com/product/2478

// Tutorial:
// https://learn.adafruit.com/adafruit-2-4-color-tft-touchscreen-breakout?view=all

// SPI an ESP32
// https://randomnerdtutorials.com/esp32-spi-communication-arduino/

/***************************************************
  This is our touchscreen painting example for the Adafruit ILI9341 Breakout
  ----> http://www.adafruit.com/products/1770

  Check out the links above for our tutorials and wiring diagrams
  These displays use SPI to communicate, 4 or 5 pins are required to
  interface (RST is optional)
  Adafruit invests time and resources providing this open source code,
  please support Adafruit and open-source hardware by purchasing
  products from Adafruit!

  Written by Limor Fried/Ladyada for Adafruit Industries.
  MIT license, all text above must be included in any redistribution
 ****************************************************/

/** NOT FOR USE WITH THE TOUCH SHIELD, ONLY FOR THE BREAKOUT! **/

// ESP32 NodeMCU (AZ-Delivery)

/* Pins f√ºr ESP32 General Purpose SPI2 (GP-SPI2, HSPI)
  GND -   ESP Pin GND
  VIN -   ESP Pin 3V3 OUT
  CLK -   ESP Pin 18
  MISO -  ESP Pin 19
  MOSI -  ESP Pin 23
  CS -    ESP Pin 5
  D/C -   ESP Pin 21
  RST -
  Lite -
  Y+ -    ESP Pin GP 1 (ADC)
  X+ -    ESP Pin GP 21
  Y- -    ESP Pin GP 20
  X- -    ESP Pin GP 2 (ADC)
  IM0 -
  IM1 -
  IM2 -
  IM3 -
  CCS - (SD card chip select)
  CD -  (SD Card detect)
*/

#include <Adafruit_GFX.h> // Core graphics library
#include <SPI.h>
#include <Wire.h>             // this is needed even tho we aren't using it
#include <Adafruit_ILI9341.h> // Display
#include <ctime>
#include "TouchScreen.h"
#include <iostream>
#include <ostream>
#include <string>
#include <stdlib.h>
#include <thread>
#include <vector>
#include "led.h"
#include "controls.h"
#include "preferences.h"

// These are the four touchscreen analog pins
#define YP 33//2  // must be an analog pin, use "An" notation!
#define XM 32//4  // must be an analog pin, use "An" notation!
#define YM 17 // can be any digital pin
#define XP 22 // can be any digital pin

// This is calibration data for the raw touch data to the screen coordinates
#define TS_MINX 150
#define TS_MINY 120
#define TS_MAXX 920
#define TS_MAXY 940

#define MINPRESSURE 10
#define MAXPRESSURE 1000

// The display also uses hardware SPI
#define TFT_CS 5
#define TFT_DC 21
Adafruit_ILI9341 tft = Adafruit_ILI9341(TFT_CS, TFT_DC);

// For better pressure precision, we need to know the resistance
// between X+ and X- Use any multimeter to read it
// For the one we're using, its 300 ohms across the X plate
// Joachim: Wert von 355 Ohm gemessen
TouchScreen ts = TouchScreen(XP, YP, XM, YM, 355);

// variables for the timer
unsigned long button_delay{300};
unsigned long current_time = millis();
unsigned long endtime = current_time + button_delay;

// initialize functions
bool checkTimer();

// Size of the color selection boxes and the paintbrush size
#define BOXSIZE 74

// Define the PWM pin (GPIO number)
const int pwmPin = 12; // Replace 12 with the GPIO pin you're using for PWM

// Define the PWM frequency, resolution, and channel
const int freq = 25000;   // PWM frequency (25 kHz is common for fans)
const int pwmChannel = 0; // Use PWM channel 0
const int resolution = 8; // 8-bit resolution (values from 0 to 255)

// Define the tachometer pin and variables
const int tachPin = 13; // Change this pin to your tachometer pin
volatile unsigned int rpm_count = 0;
unsigned long last_time = 0;
float rpm = 0;
bool RPM_stop = true;
int lastRPM = 0;
int last_sliderValue = 0;
int last_slider2Value = 0;

// #########################################################################################################################
/*


888               888    888                                                   d88P           .d888
888               888    888                                                  d88P           d88P"
888               888    888                                                 d88P            888
88888b.  888  888 888888 888888  .d88b.  88888b.       .d88b.  88888b.      d88P     .d88b.  888888
888 "88b 888  888 888    888    d88""88b 888 "88b     d88""88b 888 "88b    d88P     d88""88b 888
888  888 888  888 888    888    888  888 888  888     888  888 888  888   d88P      888  888 888
888 d88P Y88b 888 Y88b.  Y88b.  Y88..88P 888  888     Y88..88P 888  888  d88P       Y88..88P 888
88888P"   "Y88888  "Y888  "Y888  "Y88P"  888  888      "Y88P"  888  888 d88P         "Y88P"  888


*/

// Structure to hold rectangle properties
struct Rectangle
{
    int x;
    int y;
    int w;
    int h;
    uint16_t color;
    uint16_t outlineColor;
    boolean on_off;
    uint8_t *bitmap; // uint8_t is used by the drawBitmap function. specifically with "*bitmap". "*bitmap" is not a name. !!!access it with "rect.bitmap"
};

// bitmaps
unsigned char fan_bitmap[] = {0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xfc, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfc, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xf0, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x3c, 0xf0, 0x00, 0x00, 0xff, 0x80, 0x00, 0x00, 0x00, 0x3c, 0xf0, 0x00, 0x01, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x3c, 0xf0, 0x00, 0x07, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x3c, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x3c, 0xf0, 0x00, 0x0f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x3c, 0xf0, 0x00, 0x1f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x3c, 0xf0, 0x00, 0x1f, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x3c, 0xf0, 0x00, 0x3f, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x3c, 0xf0, 0x00, 0x3f, 0xff, 0x80, 0x00, 0x78, 0x00, 0x3c, 0xf0, 0x00, 0x3f, 0xff, 0x80, 0x03, 0xfe, 0x00, 0x3c, 0xf0, 0x00, 0x3f, 0xff, 0x80, 0x07, 0xff, 0x80, 0x3c, 0xf0, 0x00, 0x3f, 0xff, 0x00, 0x1f, 0xff, 0xc0, 0x3c, 0xf0, 0x00, 0x3f, 0xff, 0x00, 0x3f, 0xff, 0xe0, 0x3c, 0xf0, 0x00, 0x1f, 0xff, 0x00, 0x3f, 0xff, 0xe0, 0x3c, 0xf0, 0x00, 0x1f, 0xff, 0x00, 0x7f, 0xff, 0xf0, 0x3c, 0xf0, 0x00, 0x0f, 0xff, 0x00, 0xff, 0xff, 0xf0, 0x3c, 0xf0, 0x00, 0x07, 0xff, 0x80, 0xff, 0xff, 0xf8, 0x3c, 0xf0, 0x00, 0x03, 0xff, 0x81, 0xff, 0xff, 0xf8, 0x3c, 0xf0, 0x00, 0x01, 0xff, 0x81, 0xff, 0xff, 0xf8, 0x3c, 0xf0, 0x00, 0x00, 0xff, 0xc3, 0xff, 0xff, 0xf8, 0x3c, 0xf0, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xf8, 0x3c, 0xf0, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xf8, 0x3c, 0xf0, 0x00, 0x00, 0x03, 0xff, 0xf8, 0xff, 0xf0, 0x3c, 0xf0, 0x00, 0x00, 0x03, 0xcf, 0x80, 0x0f, 0xf0, 0x3c, 0xf0, 0x07, 0x00, 0x03, 0x87, 0x00, 0x07, 0xe0, 0x3c, 0xf0, 0x1f, 0x80, 0x03, 0x87, 0x00, 0x03, 0xc0, 0x3c, 0xf0, 0x3f, 0xc0, 0x07, 0xcf, 0x00, 0x00, 0x00, 0x3c, 0xf0, 0x3f, 0xf8, 0x3f, 0xff, 0x00, 0x00, 0x00, 0x3c, 0xf0, 0x7f, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x3c, 0xf0, 0x7f, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x3c, 0xf0, 0x7f, 0xff, 0xff, 0x0f, 0xfc, 0x00, 0x00, 0x3c, 0xf0, 0x7f, 0xff, 0xfe, 0x07, 0xfe, 0x00, 0x00, 0x3c, 0xf0, 0x7f, 0xff, 0xfe, 0x07, 0xff, 0x00, 0x00, 0x3c, 0xf0, 0x3f, 0xff, 0xfc, 0x07, 0xff, 0x80, 0x00, 0x3c, 0xf0, 0x3f, 0xff, 0xfc, 0x03, 0xff, 0xc0, 0x00, 0x3c, 0xf0, 0x3f, 0xff, 0xf8, 0x03, 0xff, 0xe0, 0x00, 0x3c, 0xf0, 0x1f, 0xff, 0xf0, 0x03, 0xff, 0xe0, 0x00, 0x3c, 0xf0, 0x1f, 0xff, 0xf0, 0x03, 0xff, 0xf0, 0x00, 0x3c, 0xf0, 0x0f, 0xff, 0xe0, 0x03, 0xff, 0xf0, 0x00, 0x3c, 0xf0, 0x07, 0xff, 0xc0, 0x07, 0xff, 0xf0, 0x00, 0x3c, 0xf0, 0x01, 0xff, 0x00, 0x07, 0xff, 0xf0, 0x00, 0x3c, 0xf0, 0x00, 0x7c, 0x00, 0x07, 0xff, 0xf0, 0x00, 0x3c, 0xf0, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf0, 0x00, 0x3c, 0xf0, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xf0, 0x00, 0x3c, 0xf0, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xe0, 0x00, 0x3c, 0xf0, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xe0, 0x00, 0x3c, 0xf0, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xc0, 0x00, 0x3c, 0xf0, 0x00, 0x00, 0x00, 0x1f, 0xff, 0x80, 0x00, 0x3c, 0xf0, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x00, 0x00, 0x3c, 0xf0, 0x00, 0x00, 0x00, 0x07, 0xfc, 0x00, 0x00, 0x3c, 0xf0, 0x00, 0x00, 0x00, 0x01, 0xe0, 0x00, 0x00, 0x3c, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xfc, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xfc, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0};
unsigned char LED_bitmap[] = {0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xe0, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xfc, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xfe, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xf8, 0x1f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xf8, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0x81, 0xe0, 0x00, 0x00, 0x03, 0xcf, 0x03, 0xff, 0xff, 0xf0, 0xf0, 0x00, 0x00, 0x03, 0xef, 0x0f, 0xff, 0xff, 0xf8, 0x78, 0x00, 0x00, 0x03, 0xef, 0x1f, 0xff, 0xff, 0xfc, 0x78, 0x00, 0x00, 0x03, 0xef, 0xbf, 0xff, 0xff, 0xfe, 0x38, 0x00, 0x00, 0x03, 0xef, 0xbf, 0xff, 0xff, 0xfe, 0x3c, 0x00, 0x00, 0x3b, 0xef, 0xbf, 0xff, 0xff, 0xff, 0x3c, 0x00, 0x00, 0x7b, 0xef, 0xbf, 0xff, 0xff, 0xff, 0x3c, 0x00, 0x00, 0xfb, 0xef, 0xbf, 0xff, 0xff, 0xff, 0xfc, 0x07, 0xfc, 0xfb, 0xef, 0xbf, 0xff, 0xff, 0xff, 0xfc, 0x1f, 0xfc, 0xf9, 0xef, 0x9f, 0xff, 0xff, 0xff, 0xfc, 0x1f, 0xfc, 0xf9, 0xe7, 0x9f, 0xff, 0xff, 0xff, 0xfc, 0x07, 0xfc, 0x79, 0xf7, 0x9f, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x39, 0xf7, 0x9f, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x19, 0xf7, 0x9f, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x01, 0xf7, 0xdf, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x01, 0xf7, 0xcf, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x01, 0xf7, 0xc7, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0xf7, 0xc3, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xfe, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xfc, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xe0, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00};
unsigned char empty_bitmap[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

// Array of rectangles
Rectangle rectangles[] = {
    {0, 0, BOXSIZE, BOXSIZE, ILI9341_BLUE, ILI9341_LIGHTGREY, false, fan_bitmap},
    {BOXSIZE + 9, 0, BOXSIZE, BOXSIZE, ILI9341_BLUE, ILI9341_LIGHTGREY, false, LED_bitmap},
    {BOXSIZE * 2 + 18, 0, BOXSIZE, BOXSIZE, ILI9341_BLUE, ILI9341_LIGHTGREY, false, empty_bitmap},
    {0, BOXSIZE + 9, BOXSIZE, BOXSIZE, ILI9341_BLUE, ILI9341_LIGHTGREY, false, empty_bitmap}};
const int numRectangles = sizeof(rectangles) / sizeof(rectangles[0]);

// Function to draw all rectangles
void drawRectangles()
{
    for (int i = 0; i < numRectangles; i++)
    {
        Rectangle rect = rectangles[i];
        if (rect.on_off == true)
        {

            tft.fillRoundRect(rect.x, rect.y, rect.w, rect.h, 10, rect.color);
            tft.drawBitmap(rect.x + 2, rect.y + 2, rect.bitmap, 70, 70, ILI9341_GREENYELLOW);
            tft.drawRoundRect(rect.x, rect.y, rect.w, rect.h, 10, rect.outlineColor);
        }
        else
        {
            tft.fillRoundRect(rect.x, rect.y, rect.w, rect.h, 10, ILI9341_BLACK);
            tft.drawBitmap(rect.x + 2, rect.y + 2, rect.bitmap, 70, 70, ILI9341_LIGHTGREY);
            tft.drawRoundRect(rect.x, rect.y, rect.w, rect.h, 10, rect.outlineColor);
        }
    }
}

// Function to check if any rectangle is touched
int checkTouchOnRectangles()
{
    TSPoint p = ts.getPoint();

    // Only consider valid touches
    if (p.z > MINPRESSURE && p.z < MAXPRESSURE)
    {
        // Map the touchscreen coordinates to display coordinates
        int touch_x = map(p.x, TS_MINX, TS_MAXX, 0, tft.width());
        int touch_y = map(p.y, TS_MINY, TS_MAXY, 0, tft.height());

        // Loop through all rectangles to check if one is touched
        for (int i = 0; i < numRectangles; i++)
        {
            Rectangle rect = rectangles[i];
            if (touch_x >= rect.x && touch_x <= (rect.x + rect.w) &&
                touch_y >= rect.y && touch_y <= (rect.y + rect.h))
            {
                return i; // Return index of touched rectangle
            }
        }
    }

    return -1; // No rectangle touched
}

// #########################################################################################################################

bool checkTimer()
{
    // return true when the time previously specified has passed, return false if not.
    // then update endpoint.
    if (current_time > endtime)
    {
        endtime = current_time + button_delay;
        return true;
    }
    else
    {
        endtime = current_time + button_delay;
        return false;
    }
}

// #############################################################################################################################
/*

 .d8888b.  888 d8b      888
d88P  Y88b 888 Y8P      888
Y88b.      888          888
 "Y888b.   888 888  .d88888  .d88b.  888d888
    "Y88b. 888 888 d88" 888 d8P  Y8b 888P"
      "888 888 888 888  888 88888888 888
Y88b  d88P 888 888 Y88b 888 Y8b.     888
 "Y8888P"  888 888  "Y88888  "Y8888  888
*/
// Bitmaps
unsigned char LED_slider_bitmap[] = {0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfc, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x04, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xc3, 0xc0, 0x00, 0x00, 0x00, 0x00, 0xff, 0xf0, 0xe0, 0x00, 0x00, 0x0e, 0xe3, 0xff, 0xfe, 0x70, 0x00, 0x00, 0x0e, 0xe7, 0xff, 0xff, 0x30, 0x00, 0x00, 0x0e, 0xef, 0xff, 0xff, 0x38, 0x00, 0x00, 0x6f, 0xff, 0xff, 0xff, 0xb8, 0x00, 0x00, 0xef, 0xf7, 0xff, 0xff, 0x98, 0x00, 0x00, 0xef, 0xf7, 0xff, 0xff, 0xf8, 0xff, 0xc0, 0xe7, 0x77, 0xff, 0xff, 0xf8, 0xff, 0xc0, 0xe7, 0x77, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x67, 0x77, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x07, 0x77, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x07, 0x77, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x07, 0x71, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x04, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfc, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00};
unsigned char fan_slider_bitmap[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x3f, 0xf0, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x7f, 0xf8, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0xff, 0xfc, 0x00, 0x00, 0x1f, 0xfe, 0x01, 0xff, 0xfc, 0x00, 0x00, 0x1f, 0xfe, 0x03, 0xff, 0xfe, 0x00, 0x00, 0x0f, 0xfe, 0x03, 0xff, 0xfe, 0x00, 0x00, 0x0f, 0xfe, 0x07, 0xff, 0xff, 0x00, 0x00, 0x07, 0xfe, 0x07, 0xff, 0xff, 0x00, 0x00, 0x01, 0xff, 0x0f, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xcf, 0xff, 0xff, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x0f, 0xfe, 0x01, 0xfe, 0x00, 0x07, 0x00, 0x0f, 0x3c, 0x00, 0x7c, 0x00, 0x0f, 0x80, 0x0f, 0x3c, 0x00, 0x38, 0x00, 0x1f, 0xc0, 0x1f, 0xfc, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xfd, 0xff, 0xc0, 0x00, 0x00, 0x3f, 0xff, 0xfc, 0x3f, 0xe0, 0x00, 0x00, 0x3f, 0xff, 0xf8, 0x1f, 0xf8, 0x00, 0x00, 0x3f, 0xff, 0xf8, 0x1f, 0xfc, 0x00, 0x00, 0x1f, 0xff, 0xf0, 0x1f, 0xfc, 0x00, 0x00, 0x1f, 0xff, 0xf0, 0x1f, 0xfe, 0x00, 0x00, 0x0f, 0xff, 0xe0, 0x1f, 0xfe, 0x00, 0x00, 0x0f, 0xff, 0xc0, 0x1f, 0xff, 0x00, 0x00, 0x07, 0xff, 0x80, 0x1f, 0xff, 0x00, 0x00, 0x03, 0xff, 0x00, 0x1f, 0xff, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x1f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

// Slider properties
int sliderX = 0;
int sliderY = 250;
int sliderW = 240;
int sliderH = 50;
uint16_t sliderColor = ILI9341_RED;
uint16_t sliderBackground = ILI9341_WHITE;

// Function to draw the slider with a filled portion based on a percentage
void drawSlider(int fillPercent)
{
    // Draw the background of the slider
    tft.fillRoundRect(sliderX, sliderY, sliderW, sliderH, sliderH / 2, sliderBackground);

    // Calculate the width of the filled portion
    int filledWidth = map(fillPercent, 0, 100, 0, sliderW);

    // Draw the filled portion
    tft.fillRoundRect(sliderX, sliderY, filledWidth, sliderH, sliderH / 2, sliderColor);
    tft.drawBitmap(180, 250, fan_slider_bitmap, 50, 50, 0x39C8);
}

// Function to check if the slider is being touched and return the percentage (0-100)

int checkSlider()
{
    TSPoint p = ts.getPoint();
    int returnValue = -1;

    // Only consider valid touches
    if (p.z > MINPRESSURE && p.z < MAXPRESSURE)
    {
        // Map the touchscreen coordinates to display coordinates
        int touch_x = map(p.x, TS_MINX, TS_MAXX, 0, tft.width());
        int touch_y = map(p.y, TS_MINY, TS_MAXY, 0, tft.height());

        // Check if the touch is within the slider's area
        if (touch_x >= sliderX && touch_x <= (sliderX + sliderW) &&
            touch_y >= sliderY && touch_y <= (sliderY + sliderH))
        {

            // Calculate the percentage based on the touch position relative to the slider's width
            int fillPercent = map(touch_x, sliderX, sliderX + sliderW, 0, 100);
            returnValue = constrain(fillPercent, 0, 100); // Ensure the value is between 0 and 100
        }
    }

    return returnValue; // Return -1 if the slider is not being touched
}

// Slider2 properties
int slider2X = 0;
int slider2Y = 190;
int slider2W = 240;
int slider2H = 50;
uint16_t slider2Color = ILI9341_RED;
uint16_t slider2Background = ILI9341_WHITE;

// Function to draw the slider2 with a filled portion based on a percentage
void drawSlider2(int fillPercent)
{
    // Calculate the width of the filled portion
    int filledWidth = map(fillPercent, 0, 100, 0, slider2W);
    // Draw the background of the slider2
    int offset = filledWidth - slider2H;
    if(offset < 0) offset = 0;
    tft.fillRoundRect(slider2X+offset, slider2Y, slider2W - offset, slider2H, slider2H / 2, slider2Background);


    // Draw the filled portion
    tft.fillRoundRect(slider2X, slider2Y, filledWidth, slider2H, slider2H / 2, slider2Color);
    tft.drawBitmap(180, 190, LED_slider_bitmap, 50, 50, ILI9341_DARKGREY);
}

// Function to check if the slider2 is being touched and return the percentage (0-100)

int checkSlider2()
{
    TSPoint p = ts.getPoint();
    int returnValue = -1;

    // Only consider valid touches
    if (p.z > MINPRESSURE && p.z < MAXPRESSURE)
    {
        // Map the touchscreen coordinates to display coordinates
        int touch_x = map(p.x, TS_MINX, TS_MAXX, 0, tft.width());
        int touch_y = map(p.y, TS_MINY, TS_MAXY, 0, tft.height());

        // Check if the touch is within the slider2's area
        if (touch_x >= slider2X && touch_x <= (slider2X + slider2W) &&
            touch_y >= slider2Y && touch_y <= (slider2Y + slider2H))
        {

            // Calculate the percentage based on the touch position relative to the slider2's width
            int fillPercent = map(touch_x, slider2X, slider2X + slider2W, 0, 100);
            returnValue = constrain(fillPercent, 0, 100); // Ensure the value is between 0 and 100
        }
    }

    return returnValue; // Return -1 if the slider2 is not being touched
}

// #########################################################################################################################
/*

 .d888                                                                 888
d88P"                                                                  888
888                                                                    888
888888  8888b.  88888b.       .d8888b  88888b.   .d88b.   .d88b.   .d88888
888        "88b 888 "88b      88K      888 "88b d8P  Y8b d8P  Y8b d88" 888
888    .d888888 888  888      "Y8888b. 888  888 88888888 88888888 888  888
888    888  888 888  888           X88 888 d88P Y8b.     Y8b.     Y88b 888
888    "Y888888 888  888       88888P' 88888P"   "Y8888   "Y8888   "Y88888
                                       888
                                       888
                                       888

*/
// Function to set fan speed (0 to 100)
void setFanSpeed(int speedPercentage)
{
    // Constrain the percentage to stay within 0 to 100 range
    speedPercentage = constrain(speedPercentage, 0, 100);

    // Convert percentage (0-100) to PWM duty cycle (0-255)
    int dutyCycle = map(speedPercentage, 0, 100, 0, 255);

    // Set the duty cycle for the PWM channel
    ledcWrite(pwmChannel, dutyCycle);
}

// ##########################################################################################################################
//  Function to calculate RPM
/*

8888888b.  8888888b.  888b     d888
888   Y88b 888   Y88b 8888b   d8888
888    888 888    888 88888b.d88888
888   d88P 888   d88P 888Y88888P888
8888888P"  8888888P"  888 Y888P 888
888 T88b   888        888  Y8P  888
888  T88b  888        888   "   888
888   T88b 888        888       888




*/

// Interrupt Service Routine to increment pulse count
void tachISR()
{
    rpm_count++;
}

// Function to calculate RPM
void calculateRPM()
{
    current_time = millis();
    unsigned long time_diff = current_time - last_time;

    if (time_diff >= 1000)
    {                                                // Every 1 second
        rpm = (rpm_count / 6) * (60000 / time_diff); // 6 pulses per revolution
        rpm_count = 0;                               // Reset the pulse count
        last_time = current_time;                    // Update the last time
                                                     /*
                                                         tft.setCursor(90, 277);
                                                         tft.fillRoundRect(85,272,150,25,10,ILI9341_BLUE);
                                                         tft.setTextColor(ILI9341_WHITE);
                                                         tft.print("RPM:");
                                                         tft.println(rpm);
                                                     */
                                                     // only wen rpm 1= 0 print
        lastRPM = rpm;
        if (rpm == 0 && RPM_stop)
        {
            Serial.print("Fan RPM: ");
            Serial.println(rpm); // Print RPM to serial
            RPM_stop = false;
        }
        else if (rpm != 0)
        {
            RPM_stop = true;
            Serial.print("Fan RPM: ");
            Serial.println(rpm); // Print RPM to serial
        }
    }
}

// ##########################################################################################################################
/*

                  888
                  888
                  888
.d8888b   .d88b.  888888 888  888 88888b.
88K      d8P  Y8b 888    888  888 888 "88b
"Y8888b. 88888888 888    888  888 888  888
     X88 Y8b.     Y88b.  Y88b 888 888 d88P
 88888P'  "Y8888   "Y888  "Y88888 88888P"
                                  888
                                  888
                                  888

*/

void SetupScreen(void)
{
#if defined(__AVR_ATtiny85__) && (F_CPU == 8000000)
    clock_prescale_set(clock_div_1);
#endif
    // Your setup here:

    // while (!Serial);     // used for leonardo debugging

    analogReadResolution(10); // set analog input resolution to 10 bits (= same as standard Arduino)

    tft.begin();
    tft.fillScreen(ILI9341_BLACK);

    tft.setTextColor(ILI9341_WHITE);
    tft.setTextSize(2);

    // Initialize the PWM on the specified pin, channel, frequency, and resolution
    ledcSetup(pwmChannel, freq, resolution);
    ledcAttachPin(pwmPin, pwmChannel);
    // Start with the fan off (duty cycle = 0)
    setFanSpeed(0);

    // Draw all rectangles
    drawRectangles();

    // Draw the initial sliders
    drawSlider(0);  // Start with the slider at 0%
    drawSlider2(0); // Start with the slider2 at 0%

    pinMode(tachPin, INPUT_PULLUP); // Set tach pin as input with pull-up resistor
    // Attach interrupt to the tach pin, triggered on falling edge (or rising if required)
    attachInterrupt(digitalPinToInterrupt(tachPin), tachISR, FALLING);
    last_time = millis(); // Record the time of setup
}

// #######################################################################################################################

/*

888
888
888
888  .d88b.   .d88b.  88888b.
888 d88""88b d88""88b 888 "88b
888 888  888 888  888 888  888
888 Y88..88P Y88..88P 888 d88P
888  "Y88P"   "Y88P"  88888P"
                      888
                      888
                      888

*/

void UpdateScreen()
{
    // update time stuff

    // Check if the slider is being touched and get the fill percentage
    int sliderValue = checkSlider();

    // Check if the slider2 is being touched and get the fill percentage
    int slider2Value = checkSlider2();

    // Check if any rectangle is being touched
    int touchedRectIndex = checkTouchOnRectangles();

    if (touchedRectIndex >= 0)
    {
        // If a rectangle is touched, fill the screen with its color
        if (checkTimer() == 1)
        {
            Serial.println(touchedRectIndex);
            Rectangle touchedRect = rectangles[touchedRectIndex];
            Rectangle ntouchedRect = touchedRect;
            ntouchedRect.on_off = !ntouchedRect.on_off;
            rectangles[touchedRectIndex] = ntouchedRect;
            Serial.println(ntouchedRect.on_off);

            // Fan on/off
            if (touchedRectIndex == 0)
            {
                if (ntouchedRect.on_off == 0)
                {
                    setFanSpeed(0);
                }
                else
                {
                    setFanSpeed(last_sliderValue);
                }
            }

            // LED on/off
            if (touchedRectIndex == 1)
            {
                primaryAnimation = (rectangles[1].on_off ? LEDAnimation::RAINBOW_FADE : LEDAnimation::OFF);
            }
        }
        drawRectangles();
    }

    if (sliderValue >= 0)
    {
        // If slider is touched, update the fill and print the value
        drawSlider(sliderValue);
        Serial.print("Slider Value: ");
        Serial.println(String(sliderValue));
    }

    if (sliderValue != last_sliderValue && (sliderValue != -1))
    {
        if (rectangles[0].on_off == 1)
        {
            setFanSpeed(int(sliderValue));
        }

        last_sliderValue = sliderValue;
        Serial.print("Fan 1 speed: ");
        Serial.println(int(sliderValue));
    }

    if (slider2Value >= 0)
    {
        // If slider2 is touched, update the fill and print the value
        drawSlider2(slider2Value);
        Serial.print("Slider2 Value: ");
        Serial.println(String(slider2Value));
    }

    if (slider2Value != last_slider2Value && (slider2Value != -1))
    {
        UpdateLEDBrightness(static_cast<double>(slider2Value)/100.0);
        

        SaveConfig();

        last_slider2Value = slider2Value;
        Serial.print("LED brightness: ");
        Serial.println(static_cast<double>(slider2Value)/100.0);
    }

    calculateRPM(); // Call the function to calculate RPM every loop cycle
}
